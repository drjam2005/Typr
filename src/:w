#include <renderer.h>
#include <objects.h>
#include <stdlib.h>
#include <raylib.h>


Renderer::Renderer() {
    text.count = 1;
    text.lines = (Line*)malloc(sizeof(Line));
    text.lines[0].length = 0;

    text.lines[0].text = (char*)malloc(1);
    text.lines[0].text[0] = '\0';
}


void Renderer::Render() {
	DrawRectangle(0, 0, GetScreenWidth(), 35, GRAY);
	DrawRectangle(0, 30, GetScreenWidth(), 5, DARKGRAY);
    for (int line = 0; line < text.count; ++line) {
        Line* currLine = &text.lines[line];
        for (int chr = 0; chr < currLine->length; ++chr) {
            char str[] = { currLine->text[chr], '\0' };

            int posX = 30 + (chr * 15);
            int posY = 50 + (line * 20);

			Color charColor = WHITE;
            if ((index.x == chr && index.y == line) ||
			    (mode == VISUAL_LINE && index.y < visualStart.y)
				) {
				charColor = BLACK;
                DrawRectangle(posX - 2, posY - 2, 15, 20, BLUE);
            }

            DrawText(str, posX, posY, 20, charColor);
        }

        if (index.x == currLine->length && index.y == line) {
            int posX = 30 + (currLine->length * 15);
            int posY = 50 + (line * 20);
			Color highlight = GRAY;
            DrawRectangle(posX - 2, posY - 2, 15, 20, highlight);
        }
    }
}



void Renderer::Update() {
	switch(mode){
		case NORMAL:
			ParseNormal();
			break;
		case INSERT:
			ParseInsert();
			break;
		case VISUAL:
			ParseVisual();
			break;
		case VISUAL_LINE:
			ParseVisualLine();
			break;
		case COMMAND:
			break;
	}
}

void Renderer::ParseInsert(){
	int key = GetCharPressed();
	if (key >= 32 && key <= 126) {
		text.AddChar(index.y, index.x, (char)key);
		index.x++;
	}

	key = GetKeyPressed();
	if (key == KEY_TAB){
		text.AddChar(index.y, index.x, ' ');
		index.x++;
		text.AddChar(index.y, index.x,' ');
		index.x++;
		text.AddChar(index.y, index.x,' ');
		index.x++;
		text.AddChar(index.y, index.x,' ');
		index.x++;
		return;
	}
	if (key == KEY_ESCAPE){
		if(index.x)
			index.x--;
		mode = NORMAL;
		return;
	}
	if (key == KEY_BACKSPACE) {
		if (index.x > 0) {
			text.RemoveChar(index.y, index.x - 1);
			index.x--;
		} else if (index.y > 0) {
			int prevLen = text.lines[(int)index.y - 1].length;
			text.MergeLines(index.y - 1, index.y);
			index.y--;
			index.x = prevLen;
		}
	}

	if (key == KEY_ENTER) {
		text.SplitLine(index.y, index.x);
		index.y++;
		index.x = 0;
	}
}

void Renderer::ParseNormal(){
	int key = GetKeyPressed();
	// NORMAL STUFF
	if(key == KEY_H){
		if(index.x)
			index.x--;
	}
	if(key == KEY_L){
		if(index.x < text.lines[(int)index.y].length-1)
			index.x++;
	}
	if(key == KEY_J){
		if(index.y+1 < text.count){
			index.y++;
		}
		int comp = text.lines[(int)index.y].length-1;
		if(index.x > comp)
			index.x = comp;
		if(comp+1 == 0)
			index.x = 0;
	}
	if(key == KEY_K){
		if(index.y)
			index.y--;
		int comp = text.lines[(int)index.y].length-1;
		if(index.x > comp)
			index.x = comp;
		if(comp+1 == 0)
			index.x = 0;
	}

	if(key == KEY_X){
		text.RemoveChar(index.y, index.x);
		if(index.x == text.lines[(int)index.y].length)
			index.x--;
	}

	if(key == KEY_V){
		visualStart = index;
		mode = VISUAL_LINE;
	}

	// INSERT STUFF
	if(key == KEY_I){
		mode = INSERT;
	}
	if(key == KEY_A){
		mode = INSERT;
		if(index.x)
			index.x++;
	}
	if(key == KEY_O){
		mode = INSERT;
		if(IsKeyDown(KEY_LEFT_SHIFT)){
			if(!(index.y))
				return;
			text.SplitLine(--index.y, text.lines[(int)index.y+1].length);
			index.x = 0; index.y++;
		}else{
			text.SplitLine(index.y, text.lines[(int)index.y].length);
			index.x = 0; index.y++;
		}
	}
}

void Renderer::ParseVisual(){
}

void Renderer::ParseVisualLine(){
	ParseNormal();
	visualEnd = index;
}
